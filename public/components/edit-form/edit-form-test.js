import QUnit from 'steal-qunit';
import sinon from 'sinon';
import ViewModel from './edit-form.viewmodel';

// ViewModel unit tests
QUnit.module('@public/components/edit-form');

const formDef = {
  name: { type: 'string', required: true, value: null },
  enabled: { type: 'boolean' },
  age: { type: 'number', value: 35 },
  gender: { type: 'enum', options: ['male', 'female', 'neutral'].map(g => ({ text: g, value: g }))}
};

QUnit.test('ViewModel throws if no formDef supplied', () => {
  QUnit.expect(3);
  QUnit.throws(() => new ViewModel(), 'Should throw');
  QUnit.throws(() => new ViewModel({ formDef: {} }), 'Should throw (no fields)');
  try{
    new ViewModel({ formDef: { foo: 'bar' } });
    QUnit.ok(true, 'Did not throw');
  } catch(ex) {
    QUnit.notOk(true, 'Should not throw');
  }
});

QUnit.test('ViewModel init calls resetProps if no itemData is passed', () => {
  sinon.spy(ViewModel.prototype, 'resetProps');
  const vm = new ViewModel({ formDef });
  QUnit.ok(vm.resetProps.calledOnce);
  ViewModel.prototype.resetProps.restore();
});

QUnit.test('ViewModel init does NOT call resetProps if itemData is passed', () => {
  sinon.spy(ViewModel.prototype, 'resetProps');
  const vm = new ViewModel({ formDef, itemData: { name: 'Ryan' }});
  QUnit.ok(vm.resetProps.notCalled);
  ViewModel.prototype.resetProps.restore();
});

QUnit.test('setItemDefaults defaults to strings if no value is defined', () => {
  const vm = new ViewModel({ formDef });
  // The formDef defines name: null, but it should be a string on the itemData
  QUnit.ok(typeof vm.itemData.name === 'string');
});

QUnit.test('handleSave sets the status to success', (assert) => {
  const done = assert.async();
  const vm = new ViewModel({ formDef });
  QUnit.equal(vm.status, undefined);
  vm.handleSave({ preventDefault(){} });
  setTimeout(() => {
    QUnit.equal(vm.status, 'success');
    done();
  });
});

QUnit.test('handleSave calls the successCallback with the result of save() before setting the success status', (assert) => {
  const done = assert.async();
  const successCallback = (result) => {
    QUnit.equal(result.id, 1234);
    QUnit.equal(vm.status, undefined);
    setTimeout(() => {
      QUnit.equal(vm.status, 'success');
      done();
    });
  };
  const vm = new ViewModel({ formDef, itemData: { id: 1234 }, successCallback });
  vm.handleSave({ preventDefault(){} });
});

QUnit.test('handleSave sets the status to error and set the error property', (assert) => {
  const done = assert.async();
  const error = new Error('This is an error');
  const successCallback = () => {
    return Promise.reject(error);
  };
  const vm = new ViewModel({ formDef, successCallback });
  QUnit.equal(vm.status, undefined);
  vm.handleSave({ preventDefault(){} });
  setTimeout(() => {
    QUnit.equal(vm.status, 'error');
    QUnit.equal(vm.error, error);
    done();
  }, 100);
});

QUnit.test('handleSemanticChange updates corresponding fields appropriately', () => {
  const vm = new ViewModel({ formDef });

  QUnit.equal(vm.itemData.name, '');
  vm.handleSemanticChange(null, { id: vm.makeIdForProp('name'), type: 'string', value: 'some value' });
  QUnit.equal(vm.itemData.name, 'some value');

  QUnit.equal(vm.itemData.enabled, '');
  vm.handleSemanticChange(null, { id: vm.makeIdForProp('enabled'), type: 'checkbox', checked: true });
  QUnit.equal(vm.itemData.enabled, true);
});

QUnit.test('getPropFromId can parse an ID generated by makeIdForProp', () => {
  const vm = new ViewModel({ formDef });
  QUnit.equal(vm.getPropFromId(vm.makeIdForProp('someProperty')), 'someProperty');
});

QUnit.test('isNew is true only when the itemData.id is null', () => {
  const vm = new ViewModel({ formDef });
  QUnit.equal(vm.isNew, true);
  vm.itemData.id = 1234;
  QUnit.equal(vm.isNew, false);
});
