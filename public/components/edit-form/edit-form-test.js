import QUnit from 'steal-qunit';
import sinon from 'sinon';
import DefineMap from 'can-define/map/map';
import ViewModel from './edit-form.viewmodel';

// ViewModel unit tests
QUnit.module('@public/components/edit-form');

function makeType (props) {
  // NOTE: certain tests rely on the values defined here
  const definitions = Object.assign({
    // common fields
    id: 'number',
    createdAt: 'date',
    updatedAt: 'date',

    name: 'string',
    age: 'number',
    enabled: 'boolean',
    withDefault: { type: 'string', default: 'foobar'}
  }, props);
  //--------------------- name         static           prototype
  return DefineMap.extend('TestModel', { definitions }, definitions);
}

QUnit.test('ViewModel init checks ItemType validity', () => {
  const InvalidType = DefineMap.extend({});
  QUnit.throws(() => new ViewModel());
  QUnit.throws(() => new ViewModel({ ItemType: InvalidType }));
});

QUnit.test('ViewModel init calls resetProps', () => {
  sinon.spy(ViewModel.prototype, 'resetProps');
  const vm = new ViewModel({ ItemType: makeType() });
  QUnit.ok(vm.resetProps.calledOnce);
  ViewModel.prototype.resetProps.restore();
});

QUnit.test('setItemDefaults defaults to strings if no value is defined', () => {
  const vm = new ViewModel({ ItemType: makeType() });
  QUnit.ok(typeof vm.itemData.name === 'string');
});

QUnit.test('setItemDefaults uses defined defaults', () => {
  const vm = new ViewModel({ ItemType: makeType() });
  QUnit.equal(vm.itemData.withDefault, 'foobar');
  vm.formDef = {
    withDefault: { value: 'bizbang' }
  };
  vm.setItemDefaults();
  QUnit.equal(vm.itemData.withDefault, 'bizbang');
});

QUnit.test('handleSave sets the status to success', (assert) => {
  const done = assert.async();
  const ItemType = makeType({
    save: () => Promise.resolve({ id: 1234 })
  });
  const vm = new ViewModel({ ItemType });
  QUnit.equal(vm.status, undefined);
  vm.handleSave({ preventDefault(){} });
  setTimeout(() => {
    QUnit.equal(vm.status, 'success');
    done();
  });
});

QUnit.test('handleSave calls the successCallback with the result of save()', (assert) => {
  const done = assert.async();
  const ItemType = makeType({
    save: () => Promise.resolve({ id: 1234 })
  });
  const successCallback = (result) => {
    QUnit.equal(result.id, 1234);
    done();
  };
  const vm = new ViewModel({ ItemType, successCallback });
  vm.handleSave({ preventDefault(){} });
});

QUnit.test('handleSave sets the status to error and set the error property', (assert) => {
  const done = assert.async();
  const error = { message: 'This is an error' };
  const ItemType = makeType({
    save: () => Promise.reject(error)
  });
  const vm = new ViewModel({ ItemType });
  QUnit.equal(vm.status, undefined);
  vm.handleSave({ preventDefault(){} });
  setTimeout(() => {
    QUnit.equal(vm.status, 'error');
    QUnit.equal(vm.error, error);
    done();
  });
});

QUnit.test('handleChange updates corresponding fields appropriately', () => {
  const vm = new ViewModel({ ItemType: makeType() });

  QUnit.equal(vm.itemData.name, '');
  vm.handleChange(null, { id: vm.makeIdForKey('name'), type: 'string', value: 'some value' });
  QUnit.equal(vm.itemData.name, 'some value');

  QUnit.equal(vm.itemData.enabled, '');
  vm.handleChange(null, { id: vm.makeIdForKey('enabled'), type: 'checkbox', checked: true });
  QUnit.equal(vm.itemData.enabled, true);
});

QUnit.test('getEditableKeys filters out functions and other known props', () => {
  const vm = new ViewModel({ ItemType: makeType({ fooFunc(){} }) });
  const keys = vm.getEditableKeys();
  QUnit.ok(Array.isArray(keys));
  QUnit.ok(!keys.includes('id'));
  QUnit.ok(!keys.includes('createdAt'));
  QUnit.ok(!keys.includes('updatedAt'));
  QUnit.ok(!keys.includes('fooFunc'));
});

QUnit.test('getKeyFromId can parse an ID generated by makeIdForKey', () => {
  const vm = new ViewModel({ ItemType: makeType() });
  QUnit.equal(vm.getKeyFromId(vm.makeIdForKey('someProperty')), 'someProperty');
});

QUnit.test('_formDef sets the correct "type" attributes', () => {
  const vm = new ViewModel({ ItemType: makeType() });
  vm._formDef.forEach(props => {
    const key = vm.getKeyFromId(props.id);
    const def = vm.ItemType.definitions[key];
    const defType = (typeof def === 'string' ? def : def.type);
    switch(defType) {
    case 'boolean':
      QUnit.equal(props.type, 'checkbox');
      break;
    case 'string':
    case 'number':
      QUnit.equal(props.type, defType);
      break;
    }
  });
});

QUnit.test('_formDef lets user defined values prevail', () => {
  const fooChange = () => {};
  const formDef = {
    enabled: { type: 'footype' },
    withDefault: { handleChange: fooChange }
  };
  const vm = new ViewModel({ ItemType: makeType(), formDef });
  vm._formDef.forEach(props => {
    const key = vm.getKeyFromId(props.id);
    switch(key) {
    case 'enabled':
      QUnit.equal(props.type, 'footype');
      break;
    case 'withDefault':
      QUnit.equal(props.handleChange, fooChange);
      break;
    }
  });
});

QUnit.test('isNew is true only when the itemData.id is null', () => {
  const vm = new ViewModel({ ItemType: makeType() });
  QUnit.equal(vm.isNew, true);
  vm.itemData.id = 1234;
  QUnit.equal(vm.isNew, false);
});
